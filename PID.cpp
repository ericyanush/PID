/**
 * @author Nick Mosher, <codewhisperer97@gmail.com>
 * Customized by Eric Yanush, <ericyanush@gmail.com>
 *
 * A PID Controller is a method of system control in which a correctional output
 * is generated to guide the system toward a desired setpoint (aka target).
 * The PID Controller calculates the output based on the following factors:
 *
 *    Gains (proportional, integral, and derivative)
 *    Target
 *    Feedback
 *
 * The gain values act as multipliers for their corresponding components of PID
 * (more detail later).  The target is the value which the system strives to
 * reach by manipulating the output.  The feedback is the system's actual
 * position or status in regards to the physical world.
 * Another important term in PID is "error", which refers to the difference
 * between the target and the feedback.
 *
 * Each of the three components of PID contributes a unique behavior to the
 * system.
 *
 *    The Proportional component introduces a linear relationship between the
 *    error (target minus feedback) and the output.  This means that as the
 *    feedback grows further away from the target, the output grows
 *    proportionally stronger.
 *
 *        Proportional component = (P Gain) * (target - feedback)
 *
 *    The Integral component is designed to give a very precise approach of the
 *    feedback to the target.  Depending on the scale of the physical system
 *    and the precision of feedback (e.g. sensors), the proportional component
 *    alone is likely not sufficient to provide adequate power (e.g. to motors)
 *    to guide the system in regards to small-scale corrections.  The Integral
 *    component integrates the error of the system (target - feedback) over
 *    time.  If the system reaches a point where it is close but not exactly
 *    on top of the target, the integration will slowly build until it is
 *    powerful enough to overcome static resistances and move the system
 *    preciesly to the target.
 *
 *        Integral component = (I Gain) * Integral of error over time
 *
 *          *In this implementation, Integral is calculated with a running
 *          summation of the system's error, updated at each tick.
 *
 *    The Derivative component measures the rate of change of the feedback.
 *    It can reduce the strength of the output if the feedback is approaching
 *    the target too quickly or if the feedback is moving away from the target.
 *
 *        Derivative component = (D Gain) * ((error - lastError) / time - lastTime)
 *
 * The output generated by the PID Controller is the sum of the three
 * components.
 *
 *    PID output = Proportional component + Integral component + Derivative component
 */

#include "PID.h"

/**
 * Constructs the PIDController object with PID Gains and function pointers
 * for retrieving feedback (pidSource) and delivering output (pidOutput).
 * All PID gains should be positive, otherwise the system will violently diverge
 * from the target.
 * @param p The Proportional gain.
 * @param i The Integral gain.
 * @param d The Derivative gain.
 */
PID::PID(float kp, float ki, float kd)
{
    _kp = kp;
    _ki = ki;
    _kd = kd;
    target = 0;
    output = 0;
    enabled = true;
    currentFeedback = 0;
    lastFeedback = 0;
    lastError = 0;
    currentTime = 0;
    lastTime = 0;
    integralCumulation = 0;
    maxCumulation = 30000;
    inputBounded = false;
    outputBounded = false;
    inputLowerBound = 0;
    inputUpperBound = 0;
    outputBounded = false;
    outputLowerBound = 0;
    outputUpperBound = 0;
}

/**
 * This method uses the established function pointers to retrieve system
 * feedback, calculate the PID output, and deliver the correction value
 * to the parent of this PIDController.  This method should be run as
 * fast as the source of the feedback in order to provide the highest
 * resolution of control (for example, to be placed in the loop() method).
 */
void PID::process(int32_t feedback, uint32_t time)
{
    if(enabled)
    {
        //Retrieve system feedback from user callback.
        currentFeedback = feedback;
        
        //Apply input bounds if necessary.
        if(inputBounded)
        {
            if(currentFeedback > inputUpperBound)
            {
                currentFeedback = inputUpperBound;
            }
            if(currentFeedback < inputLowerBound)
            {
                currentFeedback = inputLowerBound;
            }
        }
        
        /*
         * Feedback wrapping causes two distant numbers to appear adjacent to one
         * another for the purpose of calculating the system's error.
         */
        if(feedbackWrapped)
        {
            /*
             * There are three ways to traverse from one point to another in this setup.
             *
             *    1)  Target --> Feedback
             *
             * The other two ways involve bridging a gap connected by the upper and
             * lower bounds of the feedback wrap.
             *
             *    2)  Target --> Upper Bound == Lower Bound --> Feedback
             *
             *    3)  Target --> Lower Bound == Upper Bound --> Feedback
             *
             * Of these three paths, one should always be shorter than the other two,
             * unless all three are equal, in which case it does not matter which path
             * is taken.
             */
            int regErr = target - currentFeedback;
            int altErr1 = (target - feedbackWrapLowerBound) + (feedbackWrapUpperBound - currentFeedback);
            int altErr2 = (feedbackWrapUpperBound - target) + (currentFeedback - feedbackWrapLowerBound);
            
            //Calculate the absolute values of each error.
            int regErrAbs = (regErr >= 0) ? regErr : -regErr;
            int altErr1Abs = (altErr1 >= 0) ? altErr1 : -altErr1;
            int altErr2Abs = (altErr2 >= 0) ? altErr2 : -altErr2;
            
            //Use the error with the smallest absolute value
            if(regErrAbs <= altErr1Abs && regErr <= altErr2Abs) //If reguErrAbs is smallest
            {
                error = regErr;
            }
            else if(altErr1Abs < regErrAbs && altErr1Abs < altErr2Abs) //If altErr1Abs is smallest
            {
                error = altErr1Abs;
            }
            else if(altErr2Abs < regErrAbs && altErr2Abs < altErr1Abs) //If altErr2Abs is smallest
            {
                error = altErr2Abs;
            }
        }
        else
        {
            //Calculate the error between the feedback and the target.
            error = target - currentFeedback;
        }
        
        //update time
        currentTime = time;
        
        //Calculate time since last process() cycle.
        uint32_t deltaTime = currentTime - lastTime;
        
        //Calculate the integral of the feedback data since last cycle.
        int cycleIntegral = (lastError + error / 2) * deltaTime;
        
        //Add this cycle's integral to the integral cumulation.
        integralCumulation += cycleIntegral;
        
        //Calculate the slope of the line with data from the current and last cycles.
        cycleDerivative = (error - lastError) / deltaTime;
        
        //Save time data for next iteration.
        lastTime = currentTime;
        
        //Prevent the integral cumulation from becoming overwhelmingly huge.
        if(integralCumulation > maxCumulation) integralCumulation = maxCumulation;
        if(integralCumulation < -maxCumulation) integralCumulation = -maxCumulation;
        
        //Calculate the system output based on data and PID gains.
        output = (int) ((error * _kp) + (integralCumulation * _ki) + (cycleDerivative * _kd));
        
        //Save a record of this iteration's data.
        lastFeedback = currentFeedback;
        lastError = error;
        
        //Trim the output to the bounds if needed.
        if(outputBounded)
        {
            if(output > outputUpperBound) output = outputUpperBound;
            if(output < outputLowerBound) output = outputLowerBound;
        }
    }
}

/**
 * Sets the target of this PIDController.  This system will generate
 * correction outputs indended to guide the feedback variable (such
 * as position, velocity, etc.) toward the established target.
 */
void PID::setTarget(int32_t t)
{
    target = t;
}

/**
 * Returns the current target of this PIDController.
 * @return The current target of this PIDController.
 */

int32_t PID::getTarget()
{
    return target;
}

/**
 * Returns the latest output generated by this PIDController.  This value is
 * also delivered to the parent systems via the PIDOutput function pointer
 * provided in the constructor of this PIDController.
 * @return The latest output generated by this PIDController.
 */

int32_t PID::getOutput()
{
    return output;
}

/**
 * Returns the last read feedback of this PIDController.
 * @return The
 */

int32_t PID::getFeedback()
{
    return currentFeedback;
}

/**
 * Returns the last calculated error of this PIDController.
 * @return The last calculated error of this PIDController.
 */

int32_t PID::getError()
{
    return error;
}

/**
 * Enables or disables this PIDController.
 * @param True to enable, False to disable.
 */

void PID::setEnabled(bool e)
{
    //If the PIDController was enabled and is being disabled.
    if(!e && enabled)
    {
        output = 0;
        integralCumulation = 0;
    }
    enabled = e;
}

/**
 * Tells whether this PIDController is enabled.
 * @return True for enabled, false for disabled.
 */

bool PID::isEnabled()
{
    return enabled;
}

/**
 * Sets the maximum value that the integral cumulation can reach.
 * @param max The maximum value of the integral cumulation.
 */

void PID::setMaxIntegralAccumulation(int32_t max)
{
    //If the new max is not more than 1 then the cumulation is useless.
    if(max > 1)
    {
        maxCumulation = max;
    }
}

/**
 * Returns the maximum value that the integral value can cumulate to.
 * @return The maximum value that the integral value can cumulate to.
 */

int32_t PID::getMaxIntegralAccumulation()
{
    return maxCumulation;
}

/**
 * Returns the current cumulative integral value in this PIDController.
 * @return The current cumulative integral value in this PIDController.
 */

int32_t PID::getIntegralAccumulation()
{
    return integralCumulation;
}

/**
 * Enables or disables bounds on the input.  Bounds limit the upper and
 * lower values that this PIDController will ever accept as input.
 * Outlying values will be trimmed to the upper or lower bound as necessary.
 * @param bounded True to enable input bounds, False to disable.
 */

void PID::setInputBounded(bool bounded)
{
    inputBounded = bounded;
}

/**
 * Returns whether the input of this PIDController is being bounded.
 * @return True if the input of this PIDController is being bounded.
 */

bool PID::isInputBounded()
{
    return inputBounded;
}

/**
 * Sets bounds which limit the lower and upper extremes that this PIDController
 * accepts as inputs.  Outliers are trimmed to the lower and upper bounds.
 * Setting input bounds automatically enables input bounds.
 * @param lower The lower input bound.
 * @param upper The upper input bound.
 */

void PID::setInputBounds(int32_t lower, int32_t upper)
{
    if(upper > lower)
    {
        inputBounded = true;
        inputUpperBound = upper;
        inputLowerBound = lower;
    }
}

/**
 * Returns the lower input bound of this PIDController.
 * @return The lower input bound of this PIDController.
 */

int32_t PID::getInputLowerBound()
{
    return inputLowerBound;
}

/**
 * Returns the upper input bound of this PIDController.
 * @return The upper input bound of this PIDController.
 */

int32_t PID::getInputUpperBound()
{
    return inputUpperBound;
}

/**
 * Enables or disables bounds on the output.  Bounds limit the upper and lower
 * values that this PIDController will ever generate as output.
 * @param bounded True to enable output bounds, False to disable.
 */

void PID::setOutputBounded(bool bounded)
{
    outputBounded = bounded;
}

/**
 * Returns whether the output of this PIDController is being bounded.
 * @return True if the output of this PIDController is being bounded.
 */

bool PID::isOutputBounded()
{
    return outputBounded;
}

/**
 * Sets bounds which limit the lower and upper extremes that this PIDController
 * will ever generate as output.  Setting output bounds automatically enables
 * output bounds.
 * @param lower The lower output bound.
 * @param upper The upper output bound.
 */

void PID::setOutputBounds(int32_t lower, int32_t upper)
{
    if(upper > lower)
    {
        outputBounded = true;
        outputLowerBound = lower;
        outputUpperBound = upper;
    }
}

/**
 * Returns the lower output bound of this PIDController.
 * @return The lower output bound of this PIDController.
 */

int32_t PID::getOutputLowerBound()
{
    return outputLowerBound;
}

/**
 * Returns the upper output bound of this PIDController.
 * @return The upper output bound of this PIDController.
 */

int32_t PID::getOutputUpperBound()
{
    return outputUpperBound;
}

/**
 * Enables or disables feedback wrapping.
 * Feedback wrapping causes the upper and lower bounds to appear adjacent to
 * one another when calculating system error.  This can be useful for rotating
 * systems which use degrees as units.  For example, wrapping the bounds
 * [0, 360] will cause a target of 5 and a feedback of 355 to produce an error
 * of -10 rather than 350.
 * @param wrapped True to enable feedback wrapping, False to disable.
 */

void PID::setFeedbackWrapped(bool wrapped)
{
    feedbackWrapped = wrapped;
}

/**
 * Returns whether this PIDController has feedback wrap.
 * @return Whether this PIDController has feedback wrap.
 */

bool PID::isFeedbackWrapped()
{
    return feedbackWrapped;
}

/**
 * Sets the bounds which the feedback wraps around. This
 * also enables Input Bounds at the same coordinates to
 * prevent extraneous domain errors.
 * @param lower The lower wrap bound.
 * @param upper The upper wrap bound.
 */

void PID::setFeedbackWrapBounds(int32_t lower, int32_t upper)
{
    //Make sure no value outside this circular range is ever input.
    setInputBounds(lower, upper);
    
    feedbackWrapped = true;
    feedbackWrapLowerBound = lower;
    feedbackWrapUpperBound = upper;
}

/**
 * Returns the lower feedback wrap bound.
 * @return The lower feedback wrap bound.
 */

int32_t PID::getFeedbackWrapLowerBound()
{
    return feedbackWrapLowerBound;
}

/**
 * Returns the upper feedback wrap bound.
 * @return The upper feedback wrap bound.
 */

int32_t PID::getFeedbackWrapUpperBound()
{
    return feedbackWrapUpperBound;
}

/**
 * Sets new values for all PID Gains.
 * @param kp The new proportional gain.
 * @param ki The new integral gain.
 * @param kd The new derivative gain.
 */

void PID::setPID(float kp, float ki, float kd)
{
    _kp = kp;
    _ki = ki;
    _kd = kd;
}

/**
 * Sets a new value for the proportional gain.
 * @param kp The new proportional gain.
 */

void PID::setKp(float kp)
{
    _kp = kp;
}

/**
 * Sets a new value for the integral gain.
 * @param ki The new integral gain.
 */

void PID::setKi(float ki)
{
    _ki = ki;
}

/**
 * Sets a new value for the derivative gain.
 * @param kd The new derivative gain.
 */

void PID::setKd(float kd)
{
    _kd = kd;
}

/**
 * Returns the proportional gain.
 * @return The proportional gain.
 */

float PID::getKp()
{
    return _kp;
}

/**
 * Returns the integral gain.
 * @return The integral gain.
 */

float PID::getKi()
{
    return _ki;
}

/**
 * Returns the derivative gain.
 * @return The derivative gain.
 */

float PID::getKd()
{
    return _kd;
}