/**
 * @author Nick Mosher, <codewhisperer97@gmail.com>
 * Customized by Eric Yanush, <ericyanush@gmail.com>
 *
 * A PID Controller is a method of system control in which a correctional output
 * is generated to guide the system toward a desired setpoint (aka target).
 * The PID Controller calculates the output based on the following factors:
 *
 *    Gains (proportional, integral, and derivative)
 *    Target
 *    Feedback
 *
 * The gain values act as multipliers for their corresponding components of PID
 * (more detail later).  The target is the value which the system strives to
 * reach by manipulating the output.  The feedback is the system's actual
 * position or status in regards to the physical world.
 * Another important term in PID is "error", which refers to the difference
 * between the target and the feedback.
 *
 * Each of the three components of PID contributes a unique behavior to the
 * system.
 *
 *    The Proportional component introduces a linear relationship between the
 *    error (target minus feedback) and the output.  This means that as the
 *    feedback grows further away from the target, the output grows
 *    proportionally stronger.
 *
 *        Proportional component = (P Gain) * (target - feedback)
 *
 *    The Integral component is designed to give a very precise approach of the
 *    feedback to the target.  Depending on the scale of the physical system
 *    and the precision of feedback (e.g. sensors), the proportional component
 *    alone is likely not sufficient to provide adequate power (e.g. to motors)
 *    to guide the system in regards to small-scale corrections.  The Integral
 *    component integrates the error of the system (target - feedback) over
 *    time.  If the system reaches a point where it is close but not exactly
 *    on top of the target, the integration will slowly build until it is
 *    powerful enough to overcome static resistances and move the system
 *    preciesly to the target.
 *
 *        Integral component = (I Gain) * Integral of error over time
 *
 *          *In this implementation, Integral is calculated with a running
 *          summation of the system's error, updated at each tick.
 *
 *    The Derivative component measures the rate of change of the feedback.
 *    It can reduce the strength of the output if the feedback is approaching
 *    the target too quickly or if the feedback is moving away from the target.
 *
 *        Derivative component = (D Gain) * ((error - lastError) / time - lastTime)
 *
 * The output generated by the PID Controller is the sum of the three
 * components.
 *
 *    PID output = Proportional component + Integral component + Derivative component
 */

#ifndef PID_H
#define PID_H
#endif

#include <stdint.h>

/**
 @brief This class implements a discrete PID (proportional, integral,
        derivative) controller. It can be used to manage a process actuator
        baseed on a closed feedback loop and a target setpoint. The algorithm
        implemented is capable of handling irregular feedback measurements.
 */
class PID
{
public:
    /**
     @brief Default constructor
     
     @param kp: gain multiplier for the proportional term.
     @param ki: gain multiplier for the integral term.
     @oaram kd: gain multiplier for the derivative term.
     */
    PID(float kp, float ki, float kd);
    
    /**
     @brief Process a new feedback loop measurement
     
     @param feedback: The current feedback loop measurement
     @param time: The system time when the measurement was taken.
     */
    void process(int32_t feedback, uint32_t time);
    
    /**
     @brief Update the target value of the process parameter
     
     @param target: The new desired process parameter target value
     */
    void setTarget(int32_t target);
    
    /**
     @brief Retreive the current process parameter target value
     
     @return The current target value of the process
     */
    int32_t getTarget();
    
    /**
     @brief Retrieve the last computed actuator output
     
     @return The latest commanded output value
     */
    int32_t getOutput();
    
    /**
     @brief Retrieve the last system feedback measurement
     
     @return The latest system feedback measurement value
     */
    int32_t getFeedback();
    
    /**
     @brief Retreive the last computed system error. The system error is
            the difference between the target system value and the actual
            system value.
     
     @return The last computed system error, based on the last feedback look
             measurement.
     */
    int32_t getError();
    
    /**
     @brief Enable or disable the PID control algorithm
     
     @param enable: Whether or not to enable the control algorithm
     */
    void setEnabled(bool enable);
    
    /**
     @brief check if the PID control algorithm is currently enabled
     
     @return true if the algorithm is enabled, false otherwise
     */
    bool isEnabled();
    
    /**
     @brief Set the maximum value the integral accumulator is allowed to reach
     
     @param max: The maximum value the integral accumulator is allowed to reach
     */
    void setMaxIntegralAccumulation(int32_t max);
    
    /**
     @brief Retrieve the currently configured max integral accumulatr value
     
     @return The currently configured maximum integral accumulator value
     */
    int32_t getMaxIntegralAccumulation();
    
    /**
     @brief Retrieve the current value of the integral accumulator
     
     @return The current value of the integral accumulator
     */
    int32_t getIntegralAccumulation();
    
    /**
     @brief Enable or Disable Input bounding
     
     @param bounded: True to enable input bounding, false to disable.
     */
    void setInputBounded(bool bounded);
    
    /**
     @brief Check if input bounding has been enabled
     
     @return True if input bounding is enabled, false otherwise
     */
    bool isInputBounded();
    
    /**
     @brief Configure the upper and lower input bounds
     
     @param lower: The lowest value used in the algorithm computation for
                   feedback loop measurements. If the feedback loop measurment
                   provided is less than this value, this value will be used 
                   instead.
     
     @param upper: The highest value used in the algorithm computation for
                   feedback loop measurements. If the feedback loop measurment
                   provided is higher than this value, this value will be used
                   instead.
     */
    void setInputBounds(int32_t lower, int32_t upper);
    
    /**
     @brief Retrieve the currently configured lower input bound
     
     @return The currently configured lower input bound value
     */
    int32_t getInputLowerBound();
    
    /**
     @brief Retrieve the currently configured upper input bound
     
     @return The currently configured upper input bound value
     */
    int32_t getInputUpperBound();
    
    /**
     @brief Enable or Disable Output bounding
     
     @param bounded: True to enable Output bounding, false to disable.
     */
    void setOutputBounded(bool bounded);
    
    /**
     @brief Check if output bounding has been enabled
     
     @return True if output bounding is enabled, false otherwise
     */
    bool isOutputBounded();
    
    /**
     @brief Configure the upper and lower output bounds
     
     @param lower: The lowest value the algorithm computation will command
                   for actuator output. If the computed output is lower than
                   this value, this value is used instead.
     
     @param upper: The highest value the algorithm computation will command
                   for actuator output. If the computed output is higher than
                   this value, this value is used instead.
     */
    void setOutputBounds(int32_t lower, int32_t upper);
    
    /**
     @brief Retrieve the currently configured lower output bound
     
     @return The currently configured lower output bound value
     */
    int32_t getOutputLowerBound();
    
    /**
     @brief Retrieve the currently configured upper output bound
     
     @return The currently configured upper output bound value
     */
    int32_t getOutputUpperBound();
    
    /**
     @brief Enable Feedback wrapping
            Feeback wrapping allows more efficient actuator commanding
            for systems where the upper and lower bounds of the input/output
            are adjacent. (Example gyroscope: 0 degrees and 359 degrees are 
            adjacent.) This allows the computation to command the error be 
            corrected using the shortest path.
     
     @param wrap: True to enable feedback wrapping, false to disable.
     */
    void setFeedbackWrapped(bool wrap);
    
    /**
     @brief Check if feedback wrapping has been enabled
     
     @return True if feedback wrapping is enabled, false otherwise
     */
    bool isFeedbackWrapped();
    
    /**
     @brief configure the upper and lower bounds of the feedback loop, which
            are conceptually adjacent to one another.
     
     @param lower: The lower bound of the system
     @param upper: The upper bound of the system
     */
    void setFeedbackWrapBounds(int32_t lower, int32_t upper);
    
    /**
     @brief Retrieve the currently configured lower wrapping bound of the
            feedback loop.
     
     @return The currently configured value of the lower wrapping feedback bound
     */
    int32_t getFeedbackWrapLowerBound();
    
    /**
     @brief Retrieve the currently configured upper wrapping bound of the
            feedback loop.
     
     @return The currently configured value of the upper wrapping feedback bound
     */
    int32_t getFeedbackWrapUpperBound();
    
    /**
     @brief Configure the individual algorithm component gains
     
     @param kp: The new Proportional gain value to use
     @param ki: The new Integral gain value to use
     @param kd: The new Derivative gain value to use
     */
    void setPID(float kp, float ki, float kd);
    
    /**
     @brief Configure the Proportional gain value
     
     @param kp: The new proportional gain value to use
     */
    void setKp(float kp);
    
    /**
     @brief Configure the Integral gain value
     
     @param kp: The new Integral gain value to use
     */
    void setKi(float ki);
    
    /**
     @brief Configure the Derivative gain value
     
     @param kp: The new Derivative gain value to use
     */
    void setKd(float d);
    
    /**
     @brief Retrieve the currently configured Proportional gain value
     
     @return The currently configured proportional gain value
     */
    float getKp();
    
    /**
     @brief Retrieve the currently configured Integral gain value
     
     @return The currently configured Integral gain value
     */
    float getKi();
    
    /**
     @brief Retrieve the currently configured Derivative gain value
     
     @return The currently configured Derivative gain value
     */
    float getKd();
    
private:
    float _kp;
    float _ki;
    float _kd;
    int32_t target;
    int32_t output;
    bool enabled;
    int32_t currentFeedback;
    int32_t lastFeedback;
    int32_t error;
    int32_t lastError;
    uint32_t currentTime;
    uint32_t lastTime;
    int32_t integralCumulation;
    int32_t maxCumulation;
    int32_t cycleDerivative;
    
    bool inputBounded;
    int32_t inputLowerBound;
    int32_t inputUpperBound;
    bool outputBounded;
    int32_t outputLowerBound;
    int32_t outputUpperBound;
    bool feedbackWrapped;
    int32_t feedbackWrapLowerBound;
    int32_t feedbackWrapUpperBound;
};
